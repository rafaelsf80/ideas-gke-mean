# Microservices app with Istio GKE add-on

Deployment of an Angular application with an Express backend over Google Kubernetes Engine (GKE) with Istio.
An external MongoDB database is also used, outside the Istio mesh.

The application has 2 microservices and an external MongoDB database:
- **Front-end microservice,** based on an Angular app which exposes the front-end at port 80
- **Back-end microservice**, based on Express which receives requests on port 3000, and connects to Mongo database
- **Database** with MongoDB, deployed in a container.

The full application is temporaly working through this URL: http://34.76.41.170/

# GKE cluster installation

1) Run the following command to create a GKE cluster with both Istio add-on and Stackdriver Monitoring enabled. The cluster is created in a single zone, with 4 nodes, that can scale up to 8 nodes. The nodes are in the default vpc network.

```
gcloud beta container clusters create ideas-istio-gke \
    --zone europe-west1-b --num-nodes 4 \
    --machine-type "n1-standard-2" --image-type "COS" \
    --cluster-version=1.13 \
    --enable-stackdriver-kubernetes \
    --scopes "gke-default","compute-rw" \
    --enable-autoscaling --min-nodes 4 --max-nodes 8 \
    --enable-basic-auth \
    --addons=Istio --istio-config=auth=MTLS_STRICT
```

After the cluster creation (it takes some minutes), let's configure kubectl properly
and grant permissions to the current user (this last step is required to access telemetry data and other Istio features):

```
export GCLOUD_PROJECT=$(gcloud config get-value project)
gcloud container clusters get-credentials ideas-istio-gke \
            --zone europe-west1-b --project $GCLOUD_PROJECT
kubectl create clusterrolebinding cluster-admin-binding \
    --clusterrole=cluster-admin \
    --user=$(gcloud config get-value core/account)
```

To verify the installation, let's check corresponding Kubernetes pods and services are deployed using the following command:
istio-pilot-, istio-galley-, istio-policy-, istio-telemetry-, istio-ingressgateway-, istio-sidecar-injector-, and istio-citadel-.
```
kubectl get service -n istio-system
kubectl get pods -n istio-system
```

# Installation of istioctl tool

Similar to kubectl for Kubernetes, this is the tool used to manage Istio, including network routing and security policies.
To avoid errors, make sure you download the same Istioversion used in tour GKE cluster:
```
$ curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.11 sh -
$ istioctl version
```

# Cloning this directory and deploying the app into GKE

If you have not done it, let's build and push both dockers into Container Registry:

```bash
docker build -t gcr.io/third-pulsar-248314/ideas-express:v1 .
gcloud docker -- push gcr.io/third-pulsar-248314/ideas-express:v1 

docker build -t gcr.io/third-pulsar-248314/ideas-express:v1 .
gcloud docker -- push gcr.io/third-pulsar-248314/ideas-express:v1 
```

To execute the application, let's take a look at the main yaml file `ideas.yaml`.
The file to be deployed is not that one, but the one generated by `istioctl kube-inject`.
`istioctl kube-inject` takes a Kubernetes YAML file as input, and outputs a version of that YAML which includes the Istio proxy:

Now let's deploy into GKE:
```
kubectl apply -f <(istioctl kube-inject -f ideas.yaml)
```

Now we need an Istio gateway to make our application to be accesible from outside our GKE cluster.
(second command verifies the external IP address of the gateway): 
```
kubectl apply -f ideas-gateway.yaml
kubectl get svc istio-ingressgateway -n istio-system
```






After GKE cluster is created  on a GCP project, the following will deploy the **Express container** on Google Container Registry, and then on the cluster:



```bash
docker build -t gcr.io/<PROJECT_ID>/ideas-express:latest .
gcloud docker -- push gcr.io/<PROJECT_ID>/ideas-express:latest 
kubectl run ideas-express --image gcr.io/<PROJECT_ID>/ideas-express:latest --port 3000
kubectl expose deployment ideas-express --type "LoadBalancer" 
kubectl get services
```

Same for **Angular container** (note port 80 instead of 4200)
```bash
docker build -t gcr.io/<PROJECT_ID>/ideas-angular:latest .
gcloud docker -- push gcr.io/<PROJECT_ID>/ideas-angular:latest 
kubectl run ideas-angular --image gcr.io/<PROJECT_ID>/ideas-angular:latest --port 80
kubectl expose deployment ideas-angular --type "LoadBalancer" 
kubectl get services
```

For MongoDB, the deployment as a microservice is as follows:
```bash
TO BE DONE
```

# Roadmap
- Implement user authentication and authorization, in order to allow users to create ideas and managers to approve them
- Implement RPC between microservices
- Implement Portworx with MongoDB
- Add Istio and tracing with OpenCensus libraries
